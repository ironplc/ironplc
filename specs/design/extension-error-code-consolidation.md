# Extension Error Code Consolidation

## Summary

Consolidate VS Code extension error codes (E####) to follow the same pattern as
compiler problem codes (P####): a constant primary message sourced from CSV that
is shared between the TypeScript extension code and the Sphinx documentation,
with support for additional contextual information appended at each call site.

## Motivation

Currently, the compiler and extension handle error messages differently:

**Compiler (P-codes) — the model to follow:**
- `problem-codes.csv` is the single source of truth for code, name, and message
- `build.rs` generates a Rust `Problem` enum with `code()` and `message()` methods
- Diagnostic creation uses the constant message as the description, with instance-specific
  context provided through labels and `with_context()`
- The LSP formats the output as `"{description}: {primary.message}"`
- The Sphinx `problem-summary` directive reads the same CSV to render the message in docs

**Extension (E-codes) — current state:**
- `integrations/vscode/resources/problem-codes.csv` defines code, name, and message
- The CSV message is **only consumed by Sphinx** for documentation
- Extension TypeScript code **hardcodes** messages as inline strings (e.g.,
  `'E0001 - Unable to locate IronPLC compiler. Tried ...'`)
- The primary message in code and the CSV message are manually kept in sync
- There is no build-time generation or runtime lookup from the CSV

This means the extension error messages have two independent sources:
the CSV (for docs) and inline strings (for the extension). These can drift
apart and there is no enforcement that they match.

## Design

### Approach: Build-Time TypeScript Generation from CSV

Mirror the compiler's pattern: a build step reads the extension CSV and generates
a TypeScript module with constants. The extension imports these constants and
composes the full user-facing message by combining the constant primary message
with instance-specific context.

This approach was chosen over alternatives because:
- **Runtime JSON loading** adds complexity and failure modes to extension activation
- **Manually maintained constants** can drift from the CSV
- **Build-time generation** is the proven pattern already used by the compiler

### Generated TypeScript Module

A build script reads `integrations/vscode/resources/problem-codes.csv` and
generates a TypeScript file (e.g., `integrations/vscode/src/problems.ts`):

```typescript
// This file is automatically generated from resources/problem-codes.csv.
// Do not edit manually.

export const ProblemCode = {
  NoCompiler: "E0001",
  ViewerCompilerNotFound: "E0002",
  DisassemblyFailed: "E0003",
} as const;
export type ProblemCode = typeof ProblemCode[keyof typeof ProblemCode];

export const PROBLEM_MESSAGES: Record<ProblemCode, string> = {
  [ProblemCode.NoCompiler]: "Unable to locate IronPLC compiler",
  [ProblemCode.ViewerCompilerNotFound]: "IronPLC compiler not found when opening .iplc file",
  [ProblemCode.DisassemblyFailed]: "Failed to disassemble .iplc bytecode file",
};

/** Format an error message with code prefix and optional context. */
export function formatProblem(code: ProblemCode, context?: string): string {
  const message = PROBLEM_MESSAGES[code];
  if (context) {
    return `${code} - ${message}. ${context}`;
  }
  return `${code} - ${message}`;
}
```

**Why not `const enum`?** The extension uses esbuild for bundling, which processes
files independently and cannot inline `const enum` values across module boundaries.
Using `as const` with a plain object provides the same type safety and works with
all bundlers.

### Build Script

A plain JavaScript script at `integrations/vscode/scripts/generate-problems.js`:

1. Reads `integrations/vscode/resources/problem-codes.csv`
2. Parses CSV rows into code, name, message triples
3. Writes the generated TypeScript file
4. This script runs as part of the VS Code extension build (npm script in `package.json`)

The script must be **plain JavaScript** (not TypeScript) because it runs before
TypeScript compilation — a TypeScript generator would need its own compilation
step first, creating a circular dependency.

The script should:
- Include a header comment stating the file is generated
- Fail the build if the CSV is malformed
- Be invoked via an npm script (e.g., `"generate-problems"`) that runs before `compile`

### Message Format

The user-facing message format becomes:

```
{code} - {primary message}[. {contextual detail}]
```

Examples:
- `E0001 - Unable to locate IronPLC compiler. IronPLC is not installed or not configured.`
- `E0002 - IronPLC compiler not found when opening .iplc file. Install the compiler to view .iplc files.`
- `E0003 - Failed to disassemble .iplc bytecode file. Connection timed out.`
- `E0001 - Unable to locate IronPLC compiler` (no context — also valid)

### Documentation Pipeline (unchanged)

The Sphinx `problem-summary` directive already reads
`integrations/vscode/resources/problem-codes.csv` and renders the message. This
pipeline does not change. The consolidation ensures that the message displayed in
VS Code and the message shown in docs come from the same CSV row.

### Parallel with Compiler Pattern

| Aspect | Compiler (P-codes) | Extension (E-codes) — proposed |
|---|---|---|
| Source of truth | `compiler/problems/resources/problem-codes.csv` | `integrations/vscode/resources/problem-codes.csv` |
| Code generation | `build.rs` → Rust `Problem` enum | `scripts/generate-problems.js` → TypeScript module |
| Primary message | `Problem::X.message()` | `PROBLEM_MESSAGES[ProblemCode.X]` |
| Instance context | `Label::span(...)` + `with_context()` | `formatProblem(code, context)` |
| Formatted output | `"{description}: {primary.message}"` | `"{code} - {message}. {context}"` |
| Docs | `.. problem-summary::` reads CSV | `.. problem-summary::` reads CSV (unchanged) |

## Decisions

1. **Generator language**: Plain JavaScript. The generator runs before TypeScript
   compilation, so using TypeScript would require its own compilation step first.
2. **Generated file in git**: Gitignored, generated on build. This mirrors the
   compiler's approach where `problems.rs` is generated into `OUT_DIR` and not
   committed.

## Implementation Plan

See [Implementation Plan: Extension Error Code Consolidation](../plans/extension-error-code-consolidation-impl.md) for the detailed implementation steps.
