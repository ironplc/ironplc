# Extension Error Code Consolidation

## Summary

Consolidate VS Code extension error codes (E####) to follow the same pattern as
compiler problem codes (P####): a constant primary message sourced from CSV that
is shared between the TypeScript extension code and the Sphinx documentation,
with support for additional contextual information appended at each call site.

## Motivation

Currently, the compiler and extension handle error messages differently:

**Compiler (P-codes) — the model to follow:**
- `problem-codes.csv` is the single source of truth for code, name, and message
- `build.rs` generates a Rust `Problem` enum with `code()` and `message()` methods
- Diagnostic creation uses the constant message as the description, with instance-specific
  context provided through labels and `with_context()`
- The LSP formats the output as `"{description}: {primary.message}"`
- The Sphinx `problem-summary` directive reads the same CSV to render the message in docs

**Extension (E-codes) — current state:**
- `integrations/vscode/resources/problem-codes.csv` defines code, name, and message
- The CSV message is **only consumed by Sphinx** for documentation
- Extension TypeScript code **hardcodes** messages as inline strings (e.g.,
  `'E0001 - Unable to locate IronPLC compiler. Tried ...'`)
- The primary message in code and the CSV message are manually kept in sync
- There is no build-time generation or runtime lookup from the CSV

This means the extension error messages have two independent sources:
the CSV (for docs) and inline strings (for the extension). These can drift
apart and there is no enforcement that they match.

## Design

### Approach: Build-Time TypeScript Generation from CSV

Mirror the compiler's pattern: a build step reads the extension CSV and generates
a TypeScript module with constants. The extension imports these constants and
composes the full user-facing message by combining the constant primary message
with instance-specific context.

This approach was chosen over alternatives because:
- **Runtime JSON loading** adds complexity and failure modes to extension activation
- **Manually maintained constants** can drift from the CSV
- **Build-time generation** is the proven pattern already used by the compiler

### Generated TypeScript Module

A build script reads `integrations/vscode/resources/problem-codes.csv` and
generates a TypeScript file (e.g., `integrations/vscode/src/problems.ts`):

```typescript
// This file is automatically generated from resources/problem-codes.csv.
// Do not edit manually.

export const enum ProblemCode {
  NoCompiler = "E0001",
  ViewerCompilerNotFound = "E0002",
  DisassemblyFailed = "E0003",
}

export const PROBLEM_MESSAGES: Record<string, string> = {
  [ProblemCode.NoCompiler]: "Unable to locate IronPLC compiler",
  [ProblemCode.ViewerCompilerNotFound]: "IronPLC compiler not found when opening .iplc file",
  [ProblemCode.DisassemblyFailed]: "Failed to disassemble .iplc bytecode file",
};

/** Format an error message with code prefix and optional context. */
export function formatProblem(code: ProblemCode, context?: string): string {
  const message = PROBLEM_MESSAGES[code];
  if (context) {
    return `${code} - ${message}. ${context}`;
  }
  return `${code} - ${message}`;
}
```

### Build Script

A Node.js script at `integrations/vscode/scripts/generate-problems.ts` (or `.js`):

1. Reads `integrations/vscode/resources/problem-codes.csv`
2. Parses CSV rows into code, name, message triples
3. Writes the generated TypeScript file
4. This script runs as part of the VS Code extension build (npm script in `package.json`)

The script should:
- Include a header comment stating the file is generated
- Fail the build if the CSV is malformed
- Be invoked via an npm script (e.g., `"generate-problems"`) that runs before `compile`

### Extension Code Changes

Replace hardcoded message strings with calls to the generated module:

**Before (extension.ts):**
```typescript
vscode.window.showErrorMessage(
  'E0001 - Unable to locate IronPLC compiler. Tried ' + triedLocations.join(', ') + '. IronPLC is not installed or not configured.',
  'Open Online Help'
).then((item) => {
  openProblemInBrowser('E0001');
});
```

**After (extension.ts):**
```typescript
import { ProblemCode, formatProblem } from './problems';

vscode.window.showErrorMessage(
  formatProblem(ProblemCode.NoCompiler, 'Tried ' + triedLocations.join(', ') + '. IronPLC is not installed or not configured.'),
  'Open Online Help'
).then((item) => {
  openProblemInBrowser(ProblemCode.NoCompiler);
});
```

**Before (iplcEditorProvider.ts):**
```typescript
webviewPanel.webview.html = this.getErrorHtml(
  'E0002 - IronPLC compiler not found. Install the compiler to view .iplc files.',
);
```

**After (iplcEditorProvider.ts):**
```typescript
import { ProblemCode, formatProblem } from './problems';

webviewPanel.webview.html = this.getErrorHtml(
  formatProblem(ProblemCode.ViewerCompilerNotFound, 'Install the compiler to view .iplc files.'),
);
```

### Message Format

The user-facing message format becomes:

```
{code} - {primary message}[. {contextual detail}]
```

Examples:
- `E0001 - Unable to locate IronPLC compiler. Tried configuration: (/path), homebrew: (/opt/homebrew/bin/ironplcc). IronPLC is not installed or not configured.`
- `E0002 - IronPLC compiler not found when opening .iplc file. Install the compiler to view .iplc files.`
- `E0003 - Failed to disassemble .iplc bytecode file. Connection timed out.`
- `E0001 - Unable to locate IronPLC compiler` (no context — also valid)

### Documentation Pipeline (unchanged)

The Sphinx `problem-summary` directive already reads
`integrations/vscode/resources/problem-codes.csv` and renders the message. This
pipeline does not change. The consolidation ensures that the message displayed in
VS Code and the message shown in docs come from the same CSV row.

### Parallel with Compiler Pattern

| Aspect | Compiler (P-codes) | Extension (E-codes) — proposed |
|---|---|---|
| Source of truth | `compiler/problems/resources/problem-codes.csv` | `integrations/vscode/resources/problem-codes.csv` |
| Code generation | `build.rs` → Rust `Problem` enum | `scripts/generate-problems.ts` → TypeScript module |
| Primary message | `Problem::X.message()` | `PROBLEM_MESSAGES[ProblemCode.X]` |
| Instance context | `Label::span(...)` + `with_context()` | `formatProblem(code, context)` |
| Formatted output | `"{description}: {primary.message}"` | `"{code} - {message}. {context}"` |
| Docs | `.. problem-summary::` reads CSV | `.. problem-summary::` reads CSV (unchanged) |

## File Changes

| File | Change |
|---|---|
| `integrations/vscode/resources/problem-codes.csv` | No change (already correct) |
| `integrations/vscode/scripts/generate-problems.ts` | **New** — build script to generate TypeScript from CSV |
| `integrations/vscode/src/problems.ts` | **New** (generated) — constants and helper |
| `integrations/vscode/src/extension.ts` | Replace hardcoded E0001 string with `formatProblem()` |
| `integrations/vscode/src/iplcEditorProvider.ts` | Replace hardcoded E0002/E0003 strings with `formatProblem()` |
| `integrations/vscode/package.json` | Add `generate-problems` npm script, wire into build |
| `integrations/vscode/.gitignore` | Add `src/problems.ts` (generated file) |

## Testing

- Verify the generated file contains expected constants for all CSV rows
- Verify `formatProblem()` produces correct output with and without context
- Verify the extension compiles and runs with the generated module
- Verify Sphinx docs still build and render the same messages

## Open Questions

1. **Generator language**: Should the build script be TypeScript (run with `tsx`/`ts-node`)
   or plain JavaScript? Plain JS avoids a dev dependency but TypeScript is more
   consistent with the extension codebase.
2. **Generated file in git**: Should `src/problems.ts` be committed (like some
   projects do for generated files) or gitignored and generated on build? Committing
   makes it visible in code review but adds maintenance burden. Gitignoring mirrors
   the compiler's approach (the generated `problems.rs` is in `OUT_DIR`, not committed).
