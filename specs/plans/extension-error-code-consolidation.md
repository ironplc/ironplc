# Extension Error Code Consolidation

## Summary

Consolidate VS Code extension error codes (E####) to follow the same pattern as
compiler problem codes (P####): a constant primary message sourced from CSV that
is shared between the TypeScript extension code and the Sphinx documentation,
with support for additional contextual information appended at each call site.

## Motivation

Currently, the compiler and extension handle error messages differently:

**Compiler (P-codes) — the model to follow:**
- `problem-codes.csv` is the single source of truth for code, name, and message
- `build.rs` generates a Rust `Problem` enum with `code()` and `message()` methods
- Diagnostic creation uses the constant message as the description, with instance-specific
  context provided through labels and `with_context()`
- The LSP formats the output as `"{description}: {primary.message}"`
- The Sphinx `problem-summary` directive reads the same CSV to render the message in docs

**Extension (E-codes) — current state:**
- `integrations/vscode/resources/problem-codes.csv` defines code, name, and message
- The CSV message is **only consumed by Sphinx** for documentation
- Extension TypeScript code **hardcodes** messages as inline strings (e.g.,
  `'E0001 - Unable to locate IronPLC compiler. Tried ...'`)
- The primary message in code and the CSV message are manually kept in sync
- There is no build-time generation or runtime lookup from the CSV

This means the extension error messages have two independent sources:
the CSV (for docs) and inline strings (for the extension). These can drift
apart and there is no enforcement that they match.

## Design

### Approach: Build-Time TypeScript Generation from CSV

Mirror the compiler's pattern: a build step reads the extension CSV and generates
a TypeScript module with constants. The extension imports these constants and
composes the full user-facing message by combining the constant primary message
with instance-specific context.

This approach was chosen over alternatives because:
- **Runtime JSON loading** adds complexity and failure modes to extension activation
- **Manually maintained constants** can drift from the CSV
- **Build-time generation** is the proven pattern already used by the compiler

### Generated TypeScript Module

A build script reads `integrations/vscode/resources/problem-codes.csv` and
generates a TypeScript file (e.g., `integrations/vscode/src/problems.ts`):

```typescript
// This file is automatically generated from resources/problem-codes.csv.
// Do not edit manually.

export const ProblemCode = {
  NoCompiler: "E0001",
  ViewerCompilerNotFound: "E0002",
  DisassemblyFailed: "E0003",
} as const;
export type ProblemCode = typeof ProblemCode[keyof typeof ProblemCode];

export const PROBLEM_MESSAGES: Record<ProblemCode, string> = {
  [ProblemCode.NoCompiler]: "Unable to locate IronPLC compiler",
  [ProblemCode.ViewerCompilerNotFound]: "IronPLC compiler not found when opening .iplc file",
  [ProblemCode.DisassemblyFailed]: "Failed to disassemble .iplc bytecode file",
};

/** Format an error message with code prefix and optional context. */
export function formatProblem(code: ProblemCode, context?: string): string {
  const message = PROBLEM_MESSAGES[code];
  if (context) {
    return `${code} - ${message}. ${context}`;
  }
  return `${code} - ${message}`;
}
```

**Why not `const enum`?** The extension uses esbuild for bundling, which processes
files independently and cannot inline `const enum` values across module boundaries.
Using `as const` with a plain object provides the same type safety and works with
all bundlers.

### Build Script

A plain JavaScript script at `integrations/vscode/scripts/generate-problems.js`:

1. Reads `integrations/vscode/resources/problem-codes.csv`
2. Parses CSV rows into code, name, message triples
3. Writes the generated TypeScript file
4. This script runs as part of the VS Code extension build (npm script in `package.json`)

The script must be **plain JavaScript** (not TypeScript) because it runs before
TypeScript compilation — a TypeScript generator would need its own compilation
step first, creating a circular dependency.

The script should:
- Include a header comment stating the file is generated
- Fail the build if the CSV is malformed
- Be invoked via an npm script (e.g., `"generate-problems"`) that runs before `compile`

### Build Pipeline Integration

The generate step must run before **all** build paths. Update `package.json` scripts:

```json
{
  "generate-problems": "node scripts/generate-problems.js",
  "precompile": "npm run generate-problems",
  "compile": "tsc -p ./",
  "esbuild-base": "npm run generate-problems && esbuild ./src/extension.ts --bundle --outfile=out/extension.js --external:vscode --format=cjs --platform=node",
  "vscode:prepublish": "npm run esbuild-base -- --minify"
}
```

This ensures `generate-problems` runs before:
- `compile` (tsc, used for tests/development) — via the `precompile` hook
- `esbuild-base` (bundling) — via explicit chaining
- `vscode:prepublish` (production packaging) — transitively via `esbuild-base`

### Extension Code Changes

Replace hardcoded message strings with calls to the generated module.

**extension.ts — E0001 (compiler not found on activation):**

Before:
```typescript
vscode.window.showErrorMessage(
  'E0001 - Unable to locate IronPLC compiler. IronPLC is not installed or not configured.',
  'Open Online Help',
).then(() => {
  openProblemInBrowser('E0001');
});
```

After:
```typescript
import { ProblemCode, formatProblem } from './problems';

vscode.window.showErrorMessage(
  formatProblem(ProblemCode.NoCompiler, 'IronPLC is not installed or not configured.'),
  'Open Online Help',
).then(() => {
  openProblemInBrowser(ProblemCode.NoCompiler);
});
```

**iplcEditorLogic.ts — E0002 (client not ready when opening .iplc):**

Before:
```typescript
return getErrorHtml(
  'E0002 - IronPLC compiler not found. Install the compiler to view .iplc files.',
);
```

After:
```typescript
import { ProblemCode, formatProblem } from './problems';

return getErrorHtml(
  formatProblem(ProblemCode.ViewerCompilerNotFound, 'Install the compiler to view .iplc files.'),
);
```

**iplcEditorLogic.ts — E0003 (disassembly request failed):**

Before:
```typescript
return getErrorHtml(`E0003 - Failed to disassemble .iplc file: ${message}`);
```

After:
```typescript
return getErrorHtml(formatProblem(ProblemCode.DisassemblyFailed, message));
```

Note: E0003 currently uses `: ` as the separator between the primary message and
context, while the new `formatProblem` uses `. `. This is an intentional change
to make all error messages use a consistent format. The period separator reads
better when the context is a complete sentence (e.g., "Connection timed out.").

**extension.ts — `openProblemInBrowser` signature:**

The function currently takes a plain `string`. Update it to accept `ProblemCode`:

```typescript
function openProblemInBrowser(code: ProblemCode) {
  vscode.env.openExternal(vscode.Uri.parse('https://www.ironplc.com/vscode/problems/' + code + '.html'));
}
```

### Message Format

The user-facing message format becomes:

```
{code} - {primary message}[. {contextual detail}]
```

Examples:
- `E0001 - Unable to locate IronPLC compiler. IronPLC is not installed or not configured.`
- `E0002 - IronPLC compiler not found when opening .iplc file. Install the compiler to view .iplc files.`
- `E0003 - Failed to disassemble .iplc bytecode file. Connection timed out.`
- `E0001 - Unable to locate IronPLC compiler` (no context — also valid)

### Documentation Pipeline (unchanged)

The Sphinx `problem-summary` directive already reads
`integrations/vscode/resources/problem-codes.csv` and renders the message. This
pipeline does not change. The consolidation ensures that the message displayed in
VS Code and the message shown in docs come from the same CSV row.

### Parallel with Compiler Pattern

| Aspect | Compiler (P-codes) | Extension (E-codes) — proposed |
|---|---|---|
| Source of truth | `compiler/problems/resources/problem-codes.csv` | `integrations/vscode/resources/problem-codes.csv` |
| Code generation | `build.rs` → Rust `Problem` enum | `scripts/generate-problems.js` → TypeScript module |
| Primary message | `Problem::X.message()` | `PROBLEM_MESSAGES[ProblemCode.X]` |
| Instance context | `Label::span(...)` + `with_context()` | `formatProblem(code, context)` |
| Formatted output | `"{description}: {primary.message}"` | `"{code} - {message}. {context}"` |
| Docs | `.. problem-summary::` reads CSV | `.. problem-summary::` reads CSV (unchanged) |

## File Changes

| File | Change |
|---|---|
| `integrations/vscode/resources/problem-codes.csv` | No change (already correct) |
| `integrations/vscode/scripts/generate-problems.js` | **New** — plain JS build script to generate TypeScript from CSV |
| `integrations/vscode/src/problems.ts` | **New** (generated, gitignored) — constants and helper |
| `integrations/vscode/src/extension.ts` | Replace hardcoded E0001 string with `formatProblem()`; update `openProblemInBrowser` signature |
| `integrations/vscode/src/iplcEditorLogic.ts` | Replace hardcoded E0002/E0003 strings with `formatProblem()` |
| `integrations/vscode/package.json` | Add `generate-problems` npm script; wire into `precompile` and `esbuild-base` |
| `integrations/vscode/.gitignore` | Add `src/problems.ts` (generated file) |
| `integrations/vscode/src/test/unit/iplcEditorLogic.test.ts` | Update assertions that match on hardcoded error code strings (see Testing section) |
| `specs/steering/problem-code-management.md` | Update Extension Error Message Pattern section to use `formatProblem()` |

## Testing

### Generator script tests

Add a unit test for the generator that verifies:
- The generated file contains a `ProblemCode` entry for every CSV row
- The generated file contains a `PROBLEM_MESSAGES` entry for every CSV row
- The generator fails when given a malformed CSV

This can be a simple Node.js test that runs the generator against the real CSV
and spot-checks the output, or against a test fixture CSV.

### `formatProblem()` tests

The generated `formatProblem` function is pure and testable. Add unit tests:
- `formatProblem(ProblemCode.NoCompiler)` → `"E0001 - Unable to locate IronPLC compiler"`
- `formatProblem(ProblemCode.NoCompiler, "some context")` → `"E0001 - Unable to locate IronPLC compiler. some context"`

### Existing test updates

Tests in `iplcEditorLogic.test.ts` assert on hardcoded error strings. These tests
will continue to pass because they match on substrings (`'E0003'`, `'E0002'`,
`'connection lost'`, `'compiler not found'`) that are preserved in the new format.
However, the E0003 format changes from `"E0003 - Failed to disassemble .iplc file: connection lost"`
to `"E0003 - Failed to disassemble .iplc bytecode file. connection lost"`. The test
at line 80 (`html.includes('connection lost')`) still passes, but verify this during
implementation.

### Build verification

- Verify the extension compiles with `tsc` and bundles with `esbuild` using the generated module
- Verify Sphinx docs still build and render the same messages

## Decisions (previously open questions)

1. **Generator language**: Plain JavaScript. The generator runs before TypeScript
   compilation, so using TypeScript would require its own compilation step first.
2. **Generated file in git**: Gitignored, generated on build. This mirrors the
   compiler's approach where `problems.rs` is generated into `OUT_DIR` and not
   committed.

## Steering File Update

After implementation, update `specs/steering/problem-code-management.md` section
"Extension Error Message Pattern" (lines ~120-128) to replace the hardcoded
inline string examples with the new `formatProblem()` pattern:

```typescript
// Before (old pattern documented in steering file):
vscode.window.showErrorMessage('E0001 - Unable to locate IronPLC compiler. ...');

// After (new pattern to document):
import { ProblemCode, formatProblem } from './problems';
vscode.window.showErrorMessage(
  formatProblem(ProblemCode.NoCompiler, 'IronPLC is not installed or not configured.'),
);
```
