'''
Defines a directive that formats problem codes and automatically generates the problem index.
'''
import csv
import re
from pathlib import Path
from sphinx.locale import _
from docutils import nodes
from docutils.parsers.rst import Directive
from sys import exit
from os import listdir
from os.path import join

# Check that for each problem code that the compiler can emit that we have a file
# for that code and create a variable with the message text.
compiler_help_topics = set([v.split('.')[0] for v in listdir(join('compiler', 'problems'))])
extension_help_topics = set([v.split('.')[0] for v in listdir(join('vscode', 'problems'))])
help_topics = compiler_help_topics.union(extension_help_topics)
problem_infos = dict()

class ProblemCode:
    def __init__(self, message):
        self.message = message

definitions = [
    join('..', 'compiler', 'problems', 'resources', 'problem-codes.csv'),
    join('..', 'integrations', 'vscode', 'resources', 'problem-codes.csv')
]

for definition in definitions:
    with open(definition) as fp:
        problem_codes = csv.reader(fp)
        # Skip the header
        next(problem_codes)

        for row in problem_codes:
            code = row[0]
            if code not in help_topics:
                print('Missing help topic for ' + code)
                exit(1)
            problem_infos[code] = ProblemCode(row[2])

class ProblemSummary(Directive):
    required_arguments = 1
    def run(self):
        code = self.arguments[0]
        message = problem_infos[code].message

        items = [
            ProblemSummary.make_item('Code', code),
            ProblemSummary.make_item('Message', message),
        ]
        
        return [nodes.definition_list('', *items)]
    
    @staticmethod
    def make_item(key, value):
        return nodes.definition_list_item(
            '',
            nodes.term('', '', nodes.strong(text=key)),
            nodes.definition('', nodes.paragraph(text=value))
            )

def generate_problem_index(app, config):
    """
    Generate the problem codes index.rst file based on the problem code files present
    in the docs/compiler/problems directory.
    """
    # Get the source directory from Sphinx
    srcdir = Path(app.srcdir)
    problems_dir = srcdir / 'compiler' / 'problems'
    index_path = problems_dir / 'index.rst'
    
    if not problems_dir.exists():
        app.logger.warning(f"Problems directory not found: {problems_dir}")
        return
    
    # Find all .rst files that match the pattern P####.rst
    problem_files = []
    for file_path in problems_dir.glob('P*.rst'):
        if re.match(r'P\d+\.rst$', file_path.name) and file_path.name != 'index.rst':
            code = file_path.stem
            problem_files.append(code)
    
    if not problem_files:
        app.logger.warning("No problem code files found")
        return
    
    # Sort by problem code (natural sort to handle P0001, P2001, etc.)
    def sort_key(code):
        match = re.match(r'P(\d+)', code)
        if match:
            return int(match.group(1))
        return 0
    
    problem_files.sort(key=sort_key)
    
    # Generate the index file content
    content = """.. This file is automatically generated by the ironplc_problemcode Sphinx extension
.. Do not edit manually - your changes will be overwritten

=============
Problem Codes
=============

.. toctree::
   :maxdepth: 1

"""
    
    for code in problem_files:
        content += f"   {code} <{code}>\n"
    
    content += "\n\n"
    
    # Write the file
    with open(index_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    app.logger.info(f"Generated problem codes index with {len(problem_files)} codes")

def setup(app):
    app.add_directive("problem-summary", ProblemSummary)
    
    # Connect to the config-inited event to generate the index before building
    app.connect('config-inited', generate_problem_index)

    return {
        'version': '0.2',
        'parallel_read_safe': True,
        'parallel_write_safe': True,
    }