// generate-problems.js
//
// Reads integrations/vscode/resources/problem-codes.csv and generates
// src/problems.ts with typed constants and a formatting helper.
//
// This script is plain JavaScript because it runs before TypeScript
// compilation — using TypeScript here would create a circular dependency.

'use strict';

const fs = require('fs');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');
const CSV_PATH = path.join(ROOT, 'resources', 'problem-codes.csv');
const OUT_PATH = path.join(ROOT, 'src', 'problems.ts');

function parseCsv(text) {
  const lines = text.trimEnd().split('\n');
  if (lines.length < 2) {
    throw new Error('problem-codes.csv must have a header row and at least one data row');
  }

  const header = lines[0].split(',');
  if (header[0] !== 'Code' || header[1] !== 'Name' || header[2] !== 'Message') {
    throw new Error(
      `Unexpected CSV header: expected "Code,Name,Message" but got "${lines[0]}"`,
    );
  }

  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line === '') {
      continue;
    }
    // Split on first two commas only — message may contain commas
    const first = line.indexOf(',');
    const second = line.indexOf(',', first + 1);
    if (first === -1 || second === -1) {
      throw new Error(`Malformed CSV row ${i + 1}: "${line}"`);
    }
    const code = line.slice(0, first).trim();
    const name = line.slice(first + 1, second).trim();
    const message = line.slice(second + 1).trim();

    if (!code || !name || !message) {
      throw new Error(`Empty field in CSV row ${i + 1}: "${line}"`);
    }
    rows.push({ code, name, message });
  }

  if (rows.length === 0) {
    throw new Error('problem-codes.csv contains no data rows');
  }

  return rows;
}

function generateTypeScript(rows) {
  const lines = [
    '// This file is automatically generated from resources/problem-codes.csv.',
    '// Do not edit manually.',
    '',
    'export const ProblemCode = {',
  ];

  for (const row of rows) {
    lines.push(`  ${row.name}: "${row.code}",`);
  }

  lines.push('} as const;');
  lines.push('export type ProblemCode = typeof ProblemCode[keyof typeof ProblemCode];');
  lines.push('');
  lines.push('export const PROBLEM_MESSAGES: Record<ProblemCode, string> = {');

  for (const row of rows) {
    lines.push(`  [ProblemCode.${row.name}]: "${row.message}",`);
  }

  lines.push('};');
  lines.push('');
  lines.push('/** Format an error message with code prefix and optional context. */');
  lines.push('export function formatProblem(code: ProblemCode, context?: string): string {');
  lines.push('  const message = PROBLEM_MESSAGES[code];');
  lines.push('  if (context) {');
  lines.push('    return `${code} - ${message}. ${context}`;');
  lines.push('  }');
  lines.push('  return `${code} - ${message}`;');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

function main() {
  const csvText = fs.readFileSync(CSV_PATH, 'utf-8');
  const rows = parseCsv(csvText);
  const output = generateTypeScript(rows);
  fs.writeFileSync(OUT_PATH, output, 'utf-8');
  console.log(`Generated ${OUT_PATH} with ${rows.length} problem code(s).`);
}

main();
